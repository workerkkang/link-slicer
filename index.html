<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Link Slicer – 가로/세로/가로x세로 + 균등분할 + 스냅/잠금/스타일</title>
<style>
  :root{ --border:#cfd4dc; --muted:#6b7280; --accent:#ff4d4f; --bg:#f7f9fc; --panel:#ffffff; }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{ margin:0; display:flex; min-height:100vh; font-family:system-ui,Segoe UI,Roboto,"Apple SD Gothic Neo",Pretendard,sans-serif; background:var(--bg); color:#111827; }

  /* 사이드바 */
  #sidebar{ width:300px; border-right:1px solid var(--border); background:var(--panel); display:flex; flex-direction:column; }
  .side-header{padding:18px 16px; border-bottom:1px solid var(--border)}
  .side-header h2{margin:0;font-size:18px}
  .side-body{padding:16px; overflow:auto}
  .muted{color:var(--muted)}
  footer{padding:10px 12px; border-top:1px solid var(--border); background:#fff; font-size:12px;color:#6b7280}

  /* 업로드 박스 */
  #dropzone{
    margin-top:12px; border:2px dashed #9ca3af; border-radius:12px; background:#fafafa;
    padding:18px; text-align:center; cursor:pointer; transition:all .15s ease;
  }
  #dropzone.dragover{ border-color:var(--accent); background:#fff1f1 }
  #fileInput{ display:none }

  /* 메인 */
  #main{ flex:1; display:flex; flex-direction:column; min-width:0; }
  #topbar{ padding:12px; border-bottom:1px solid var(--border); background:#fff; display:flex; gap:10px; align-items:center; flex-wrap:wrap;}
  #topbar button{ appearance:none; border:1px solid var(--border); background:#fff; padding:8px 12px; border-radius:10px; cursor:pointer; }
  #topbar button.primary{ border-color:#dbe3ff; background:#eef3ff }
  #topbar .spacer{ flex:1 }
  .pill{font-size:12px;color:#4b5563}
  .segmode{display:flex; align-items:center; gap:10px; border:1px solid var(--border); padding:6px 10px; border-radius:10px; background:#fafafa; font-size:14px}
  .uniform{display:flex; align-items:center; gap:8px; border:1px solid var(--border); padding:6px 10px; border-radius:10px; background:#fafafa; }
  .uniform input{ width:64px; padding:6px 8px; border:1px solid var(--border); border-radius:8px; }
  .options{display:flex; align-items:center; gap:10px; border:1px solid var(--border); padding:6px 10px; border-radius:10px; background:#fafafa; }
  .options input[type="number"]{ width:70px; padding:6px 8px; border:1px solid var(--border); border-radius:8px; }
  .hint{font-size:12px; color:#6b7280}

  #workarea{ display:grid; grid-template-columns:1fr 420px; gap:14px; padding:14px; min-height:0; flex:1; overflow:hidden; }

  /* 캔버스 컨테이너 */
  #canvas-container{
    position:relative; overflow:auto; background:#e5e7eb; border:1px solid var(--border); border-radius:10px;
    display:flex; align-items:flex-start; justify-content:center; padding:18px; min-height:0;
  }

  /* 스테이지/이미지/오버레이 */
  #stage{ position:relative; display:none; }
  #uploadedImage{ display:block; max-width:100%; height:auto; border:1px solid var(--border); background:#fff; box-shadow:0 2px 8px rgba(0,0,0,.05); }
  #overlay{ position:absolute; left:0; top:0; z-index:10; pointer-events:auto; }

  /* 선 */
  .line{ position:absolute; background:var(--accent); cursor:move; box-shadow:0 0 6px rgba(255,77,79,.35); pointer-events:auto; }
  .h-line{ left:0; right:0; }
  .v-line{ top:0;  bottom:0; }

  /* 우측 패널 */
  #rightpanel{ background:#fff; border:1px solid var(--border); border-radius:10px; display:flex; flex-direction:column; min-height:0; }
  #rightpanel header{ padding:12px 12px; border-bottom:1px solid var(--border); font-weight:600 }
  #segments{ padding:12px; overflow:auto; display:flex; flex-direction:column; gap:10px; min-height:0; }

  /* 썸네일 + 입력 */
  .segrow{
    display:grid; grid-template-columns:76px 1fr; gap:10px; align-items:center; border:1px solid var(--border);
    padding:8px; border-radius:10px; background:#fafafa;
  }
  .thumb{ width:76px; height:auto; border:1px solid var(--border); border-radius:6px; display:block; background:#fff; }
  .segmeta{ font-size:12px; color:#6b7280; margin-top:4px }
  .segrow input{ width:100%; padding:8px 10px; border:1px solid var(--border); border-radius:8px; }

  #codebox{ padding:12px; border-top:1px solid var(--border); display:flex; flex-direction:column; gap:8px; }
  #code{ width:100%; min-height:120px; border:1px solid var(--border); border-radius:8px; padding:10px; font-family:ui-monospace,Consolas,monospace; }

  #previewwrap{ padding:12px; border-top:1px solid var(--border); }
  #preview{ display:flex; flex-direction:column; gap:4px; }

  #stateFile{ display:none }

  @media (max-width: 1160px){ #workarea{ grid-template-columns:1fr; } }
</style>
</head>
<body>

<!-- 사이드바 -->
<aside id="sidebar">
  <div class="side-header"><h2> [사용법 요약]</h2></div>
  <div class="side-body">
    <ol style="margin:0;padding-left:18px">
      <li>이미지 업로드(아래 박스에 <b>드래그&드롭</b> 또는 클릭)</li>
      <li>현재 선택한 <b>조각 기준</b>에 따라 선을 추가합니다.<br>
          • 가로/세로: 클릭=해당 방향, Shift=반대 방향<br>
          • 가로x세로: 클릭=가로선, Shift=세로선</li>
      <li>Alt+클릭 = 가장 가까운 선 삭제, 드래그=위치 이동</li>
      <li>필요하면 <b>행/열</b> 숫자를 넣고 “균등분할 적용”으로 자동 생성</li>
      <li>우측에서 각 조각 링크 입력 → <b>HTML 생성/복사</b></li>
    </ol>
    <div id="dropzone">
      <div style="font-weight:600; margin-bottom:4px;">이미지 업로드</div>
      <div class="muted">여기에 파일을 드래그하거나 클릭하세요</div>
      <div style="font-size:12px;color:#9ca3af;margin-top:6px;">(PNG · JPG · GIF)</div>
      <input id="fileInput" type="file" accept="image/*">
    </div>
  </div>
  <footer>모드에 따라 보이는 선이 달라집니다. (가로=가로선만, 세로=세로선만, 가로x세로=모두)</footer>
</aside>

<!-- 메인 -->
<main id="main">
  <div id="topbar">
    <button id="btnGen" class="primary" disabled>HTML 생성</button>
    <button id="btnRegen" disabled>HTML 재생성</button>
    <button id="btnCopy" disabled>코드 복사</button>
    <span class="spacer"></span>

    <div class="segmode" title="조각을 계산하는 기준">
      조각 기준:
      <label><input type="radio" name="mode" value="h" checked> 가로</label>
      <label><input type="radio" name="mode" value="v"> 세로</label>
      <label><input type="radio" name="mode" value="grid"> 가로x세로</label>
    </div>

    <div class="uniform" title="균등 간격으로 자동 분할선 생성">
      Row(행): <input id="rowsInput" type="number" min="1" value="3">
      Col(열): <input id="colsInput" type="number" min="1" value="3">
      <button id="btnUniform">균등분할 적용</button>
      <div class="hint">가로: Row만, 세로: Col만 사용</div>
    </div>

    <div class="options" title="스냅/잠금/선 스타일">
      <label><input id="lockToggle" type="checkbox"> 선 잠금</label>
      <label><input id="snapToggle" type="checkbox" checked> 스냅</label>
      스냅(px): <input id="snapTol" type="number" min="0" value="8">
      색상: <input id="lineColor" type="color" value="#ff4d4f">
      두께(px): <input id="lineThickness" type="number" min="1" value="2">
    </div>

    <span class="spacer"></span>
    <button id="btnSaveState" title="현재 작업 저장(JSON 다운로드)">상태 저장</button>
    <button id="btnLoadState" title="저장한 JSON 불러오기">상태 불러오기</button>
    <input id="stateFile" type="file" accept="application/json" />
    <button id="btnClearLines">선 모두 삭제</button>
    <span class="pill">클릭/Shift/Alt 동작은 상단 설명 참고</span>
  </div>

  <div id="workarea">
    <!-- 좌측: 이미지/오버레이 -->
    <div id="canvas-container">
      <div id="stage">
        <img id="uploadedImage" alt="업로드 이미지">
        <div id="overlay"></div>
      </div>
    </div>

    <!-- 우측: 링크/코드/미리보기 -->
    <div id="rightpanel">
      <header>조각 링크 입력 + 썸네일</header>
      <div id="segments"></div>
      <div id="codebox">
        <button id="btnPreview" disabled>미리보기 생성</button>
        <textarea id="code" placeholder="HTML 생성 후 코드가 표시됩니다" readonly></textarea>
      </div>
      <div id="previewwrap">
        <div style="font-weight:600; margin-bottom:8px;">미리보기</div>
        <div id="preview"></div>
      </div>
    </div>
  </div>
</main>

<script>
(() => {
  // 요소 -------------------------------------------------------
  const dropzone = document.getElementById('dropzone');
  const fileInput = document.getElementById('fileInput');
  const stateFile = document.getElementById('stateFile');

  const stage = document.getElementById('stage');
  const overlay = document.getElementById('overlay');
  const image = document.getElementById('uploadedImage');

  const segmentsWrap = document.getElementById('segments');
  const btnGen = document.getElementById('btnGen');
  const btnRegen = document.getElementById('btnRegen');
  const btnCopy = document.getElementById('btnCopy');
  const btnClearLines = document.getElementById('btnClearLines');
  const btnPreview = document.getElementById('btnPreview');
  const btnSaveState = document.getElementById('btnSaveState');
  const btnLoadState = document.getElementById('btnLoadState');
  const codeTA = document.getElementById('code');
  const preview = document.getElementById('preview');

  const modeRadios = document.querySelectorAll('input[name="mode"]');
  const rowsInput = document.getElementById('rowsInput');
  const colsInput = document.getElementById('colsInput');
  const btnUniform = document.getElementById('btnUniform');

  const lockToggle = document.getElementById('lockToggle');
  const snapToggle = document.getElementById('snapToggle');
  const snapTol = document.getElementById('snapTol');
  const lineColor = document.getElementById('lineColor');
  const lineThickness = document.getElementById('lineThickness');

  // 상태 -------------------------------------------------------
  let lines = []; // { type:'h'|'v', perc:0..1, el }
  let naturalW = 0, naturalH = 0;
  let segLinks = []; // 현재 모드 기준 조각 링크(그리드는 r*c 개)
  let thumbRAF = null;
  let segMode = 'h'; // 'h'|'v'|'grid'
  let uniformRows = 3, uniformCols = 3;

  // 스타일/동작 옵션
  let styleColor = '#ff4d4f';
  let styleThickness = 2;
  let locked = false;
  let snapEnabled = true;
  let snapPx = 8;

  // 유틸 -------------------------------------------------------
  function displaySize(){ return { w: overlay.clientWidth, h: overlay.clientHeight }; }
  function syncOverlaySize(){ overlay.style.width=image.clientWidth+'px'; overlay.style.height=image.clientHeight+'px'; }
  function isLineVisible(l){
    if(segMode==='h') return l.type==='h';
    if(segMode==='v') return l.type==='v';
    return true; // grid
  }
  function applyStyle(el, type){
    el.style.background = styleColor;
    if(type==='h'){
      el.style.height = styleThickness + 'px';
      el.style.top = (parseFloat(el.style.top)||0) + 'px'; // ensure unit
      el.className='line h-line';
    }else{
      el.style.width  = styleThickness + 'px';
      el.style.left = (parseFloat(el.style.left)||0) + 'px';
      el.className='line v-line';
    }
    el.style.boxShadow = `0 0 6px ${styleColor}55`;
  }
  function layoutLines(){
    const {w,h} = displaySize();
    lines.forEach(l=>{
      if(l.type==='h'){
        l.el.style.left='0'; l.el.style.right='0';
        l.el.style.top=(l.perc*h - styleThickness/2) + 'px';
      }else{
        l.el.style.top='0'; l.el.style.bottom='0';
        l.el.style.left=(l.perc*w - styleThickness/2) + 'px';
      }
      applyStyle(l.el, l.type);
      l.el.style.display = isLineVisible(l) ? '' : 'none';
      l.el.style.cursor = locked ? 'default' : 'move';
      l.el.style.pointerEvents = locked ? 'none' : 'auto';
    });
  }
  function getPercsSorted(type){ return lines.filter(l=>l.type===type).map(l=>l.perc).sort((a,b)=>a-b); }

  function markDirty(){
    btnRegen.disabled = false;
    btnPreview.disabled = true;
    btnCopy.disabled = true;
    codeTA.value = '';
    preview.innerHTML = '';
  }

  // 업로드 -----------------------------------------------------
  function loadFile(file){
    if(!file) return;
    const url = URL.createObjectURL(file);
    image.onload = () => {
      naturalW = image.naturalWidth; naturalH = image.naturalHeight;
      stage.style.display='inline-block';
      syncOverlaySize(); fullReset();
    };
    image.src=url;
  }
  dropzone.addEventListener('click', ()=>fileInput.click());
  fileInput.addEventListener('change', e=>loadFile(e.target.files?.[0]));
  ['dragenter','dragover'].forEach(t=>dropzone.addEventListener(t, e=>{e.preventDefault(); dropzone.classList.add('dragover');}));
  ['dragleave','dragend','drop'].forEach(t=>dropzone.addEventListener(t, ()=>dropzone.classList.remove('dragover')));
  dropzone.addEventListener('drop', e=>{ e.preventDefault(); const f=e.dataTransfer.files?.[0]; if(f?.type.startsWith('image/')) loadFile(f); });

  // 선 생성/삭제/스냅 ------------------------------------------
  function pointerInOverlay(ev){
    const r = overlay.getBoundingClientRect();
    const x = ev.clientX - r.left, y = ev.clientY - r.top;
    const w = overlay.clientWidth, h = overlay.clientHeight;
    return {x,y,w,h, inside:x>=0&&y>=0&&x<=w&&y<=h};
  }
  function createLine(type, perc){
    const el = document.createElement('div');
    overlay.appendChild(el);
    const obj = {type, perc: Math.max(0, Math.min(1, perc)), el};
    lines.push(obj);
    applyStyle(el, type);
    layoutLines();
    updateSegmentsUI(true);
    markDirty();

    // 드래그 이동
    let dragging=false, startClient=0, startPerc=obj.perc;
    el.addEventListener('mousedown', (e)=>{
      if(locked) return;
      e.preventDefault(); dragging=true; startClient=(type==='h')?e.clientY:e.clientX; startPerc=obj.perc;
      const onMove=(ev)=>{
        if(!dragging) return;
        const {w,h}=displaySize();
        const d=(type==='h')? (ev.clientY-startClient)/h : (ev.clientX-startClient)/w;
        let next = Math.max(0, Math.min(1, startPerc+d));

        // 스냅: 같은 타입 선 및 경계(0,1)로 흡착
        if(snapEnabled){
          const pxTol = snapPx;
          const currPx = (type==='h') ? next*h : next*w;
          let snapTargets = [0, (type==='h')?h:w]; // edges
          lines.forEach(l=>{ if(l!==obj && l.type===type) snapTargets.push((type==='h')? l.perc*h : l.perc*w); });
          let best = currPx, bestDist = Infinity;
          for(const t of snapTargets){
            const dist = Math.abs(currPx - t);
            if(dist <= pxTol && dist < bestDist){
              best = t; bestDist = dist;
            }
          }
          if(bestDist !== Infinity){
            next = (type==='h') ? best/h : best/w;
          }
        }

        obj.perc = next;
        layoutLines();
        if(segMode==='h'&&type==='h' || segMode==='v'&&type==='v' || segMode==='grid') scheduleThumbs();
        markDirty();
      };
      const onUp=()=>{ dragging=false; document.removeEventListener('mousemove', onMove); document.removeEventListener('mouseup', onUp); updateSegmentsUI(false); };
      document.addEventListener('mousemove', onMove);
      document.addEventListener('mouseup', onUp);
    });
  }
  function deleteNearest(x,y){
    if(!lines.length) return;
    const {w,h}=displaySize();
    let nearest=null, dist=Infinity;
    lines.forEach(l=>{
      if(!isLineVisible(l)) return; // 보이지 않는 선은 삭제 대상 제외
      const d=(l.type==='h')?Math.abs(l.perc*h-y):Math.abs(l.perc*w-x);
      if(d<dist){dist=d; nearest=l;}
    });
    if(nearest){
      nearest.el.remove();
      const t=nearest.type;
      lines = lines.filter(l=>l!==nearest);
      if(segMode==='grid' || segMode===t) updateSegmentsUI(true);
      markDirty();
    }
  }

  overlay.addEventListener('click', e=>{
    if(!image.src) return;
    const p=pointerInOverlay(e); if(!p.inside) return;

    if(e.altKey){ deleteNearest(p.x,p.y); return; }

    let addType = 'h';
    if(segMode==='h') addType = e.shiftKey? 'v':'h';
    else if(segMode==='v') addType = e.shiftKey? 'h':'v';
    else /* grid */ addType = e.shiftKey? 'v':'h';

    if(addType==='h') createLine('h', p.y/p.h);
    else createLine('v', p.x/p.w);
  });

  // 라디오 변경 시 보이기/숨기기 및 UI 갱신
  modeRadios.forEach(r=>r.addEventListener('change', ()=>{
    segMode = [...modeRadios].find(x=>x.checked).value; // h|v|grid
    layoutLines();
    updateSegmentsUI(true);
    markDirty();
  }));

  // 균등분할 ---------------------------------------------------
  function rebuildUniform(type, count){
    // type: 'h'|'v', count: 조각 수(행 또는 열) => 내부 선은 count-1개
    lines.filter(l=>l.type===type).forEach(l=>l.el.remove());
    lines = lines.filter(l=>l.type!==type);
    if(count<=1){ layoutLines(); updateSegmentsUI(true); return; }
    const cuts = count - 1;
    for(let i=1;i<=cuts;i++){
      const perc = i / count;
      createLine(type, perc);
    }
    layoutLines();
    updateSegmentsUI(true);
  }

  btnUniform.addEventListener('click', ()=>{
    uniformRows = Math.max(1, parseInt(rowsInput.value||'1',10));
    uniformCols = Math.max(1, parseInt(colsInput.value||'1',10));
    if(segMode==='h'){
      rebuildUniform('h', uniformRows);
    }else if(segMode==='v'){
      rebuildUniform('v', uniformCols);
    }else{
      rebuildUniform('h', uniformRows);
      rebuildUniform('v', uniformCols);
    }
    scheduleThumbs(); markDirty();
  });

  // 스타일/옵션 변경 ------------------------------------------
  lockToggle.addEventListener('change', ()=>{ locked = lockToggle.checked; layoutLines(); });
  snapToggle.addEventListener('change', ()=>{ snapEnabled = snapToggle.checked; });
  snapTol.addEventListener('input', ()=>{ snapPx = Math.max(0, parseInt(snapTol.value||'0',10)); });

  lineColor.addEventListener('input', ()=>{
    styleColor = lineColor.value || '#ff4d4f';
    layoutLines();
  });
  lineThickness.addEventListener('input', ()=>{
    styleThickness = Math.max(1, parseInt(lineThickness.value||'2',10));
    layoutLines();
  });

  // 리사이즈
  const ro=new ResizeObserver(()=>{ syncOverlaySize(); layoutLines(); scheduleThumbs(); });
  ro.observe(image); ro.observe(stage);

  btnClearLines.addEventListener('click', ()=>{
    lines.forEach(l=>l.el.remove());
    lines=[];
    updateSegmentsUI(true);
    markDirty();
  });

  // 세그먼트/썸네일 --------------------------------------------
  function scheduleThumbs(){ if(thumbRAF) cancelAnimationFrame(thumbRAF); thumbRAF=requestAnimationFrame(renderThumbnails); }

  function updateSegmentsUI(regenThumbs){
    let rows=1, cols=1, hCuts=[], vCuts=[];
    if(segMode==='h'){ hCuts=getPercsSorted('h'); rows=hCuts.length+1; cols=1; }
    else if(segMode==='v'){ vCuts=getPercsSorted('v'); rows=1; cols=vCuts.length+1; }
    else{ hCuts=getPercsSorted('h'); vCuts=getPercsSorted('v'); rows=hCuts.length+1; cols=vCuts.length+1; }

    const prev = segLinks.slice();
    segLinks = Array.from({length:rows*cols}, (_,i)=> prev[i] ?? "");

    segmentsWrap.innerHTML="";
    for(let r=0;r<rows;r++){
      for(let c=0;c<cols;c++){
        const idx = r*cols + c;
        const row = document.createElement('div');
        row.className='segrow'; row.dataset.idx=idx;

        const left = document.createElement('div');
        const img  = document.createElement('img'); img.className='thumb'; img.alt=`seg-${idx+1}`;
        left.appendChild(img);

        const meta = document.createElement('div'); meta.className='segmeta';
        if(segMode==='h') meta.textContent = `조각 ${idx+1} · 행 ${r+1}/${rows}`;
        else if(segMode==='v') meta.textContent = `조각 ${idx+1} · 열 ${c+1}/${cols}`;
        else meta.textContent = `조각 ${idx+1} · (${r+1}, ${c+1}) / ${rows}×${cols}`;
        left.appendChild(meta);

        const input = document.createElement('input');
        input.type='url'; input.placeholder='https:// 링크 입력'; input.value=segLinks[idx];
        input.addEventListener('input', ev=>{ segLinks[idx]=ev.target.value.trim(); markDirty(); });

        row.appendChild(left); row.appendChild(input);
        segmentsWrap.appendChild(row);
      }
    }

    btnGen.disabled = !image.src;
    btnPreview.disabled=true; btnCopy.disabled=true; codeTA.value=''; preview.innerHTML='';
    if(regenThumbs) scheduleThumbs();
  }

  function renderThumbnails(){
    thumbRAF=null; if(!image.src) return;

    const hPerc=[0,...getPercsSorted('h'),1];
    const vPerc=[0,...getPercsSorted('v'),1];

    const yPix = hPerc.map(p=>Math.round(p*naturalH));
    const xPix = vPerc.map(p=>Math.round(p*naturalW));

    const c=document.createElement('canvas'); const ctx=c.getContext('2d');

    if(segMode==='h' || (segMode==='grid' && vPerc.length===2 && hPerc.length>2)){
      let idx=0;
      for(let r=0;r<yPix.length-1;r++){
        const top=yPix[r], h=yPix[r+1]-yPix[r];
        const W=76, H=Math.max(1, Math.round(h*(W/naturalW)));
        c.width=W; c.height=H; ctx.clearRect(0,0,W,H);
        ctx.drawImage(image, 0, top, naturalW, h, 0, 0, W, H);
        const url=c.toDataURL('image/png');
        const imgEl=segmentsWrap.querySelector(`.segrow[data-idx="${idx}"] img.thumb`);
        if(imgEl){ imgEl.src=url; imgEl.style.width=W+'px'; }
        idx++;
      }
      if(segMode==='h') return;
    }

    if(segMode==='v' || (segMode==='grid' && hPerc.length===2 && vPerc.length>2)){
      let idx=0;
      for(let cIdx=0;cIdx<xPix.length-1;cIdx++){
        const left=xPix[cIdx], w=xPix[cIdx+1]-xPix[cIdx];
        const H=76, W=Math.max(1, Math.round(w*(H/naturalH)));
        c.width=W; c.height=H; ctx.clearRect(0,0,W,H);
        ctx.drawImage(image, left, 0, w, naturalH, 0, 0, W, H);
        const url=c.toDataURL('image/png');
        const imgEl=segmentsWrap.querySelector(`.segrow[data-idx="${idx}"] img.thumb`);
        if(imgEl){ imgEl.src=url; imgEl.style.width=W+'px'; }
        idx++;
      }
      if(segMode==='v') return;
    }

    if(segMode==='grid'){
      let idx=0;
      for(let r=0;r<yPix.length-1;r++){
        for(let cIdx=0;cIdx<xPix.length-1;cIdx++){
          const top=yPix[r], height=yPix[r+1]-yPix[r];
          const left=xPix[cIdx], width=xPix[cIdx+1]-xPix[cIdx];
          if(width<=0||height<=0) { idx++; continue; }
          const box=76, scale=Math.min(box/width, box/height);
          const W=Math.max(1, Math.round(width*scale));
          const H=Math.max(1, Math.round(height*scale));
          c.width=W; c.height=H; ctx.clearRect(0,0,W,H);
          ctx.drawImage(image, left, top, width, height, 0, 0, W, H);
          const url=c.toDataURL('image/png');
          const imgEl=segmentsWrap.querySelector(`.segrow[data-idx="${idx}"] img.thumb`);
          if(imgEl){ imgEl.src=url; imgEl.style.width=W+'px'; }
          idx++;
        }
      }
    }
  }

  // HTML 생성/재생성/복사 --------------------------------------
  function generateHTML(){
    if(!image.src) return;

    const hPerc=[0,...getPercsSorted('h'),1];
    const vPerc=[0,...getPercsSorted('v'),1];
    const ys=hPerc.map(p=>Math.round(p*naturalH));
    const xs=vPerc.map(p=>Math.round(p*naturalW));

    const canv=document.createElement('canvas');
    const ctx=canv.getContext('2d');
    const dataURLs=[];

    if(segMode==='h'){
      canv.width=naturalW;
      for(let r=0;r<ys.length-1;r++){
        const top=ys[r], h=ys[r+1]-ys[r];
        canv.height=h; ctx.clearRect(0,0,canv.width,canv.height);
        ctx.drawImage(image, 0, top, naturalW, h, 0, 0, naturalW, h);
        dataURLs.push(canv.toDataURL('image/png'));
      }
    }else if(segMode==='v'){
      canv.height=naturalH;
      for(let cIdx=0;cIdx<xs.length-1;cIdx++){
        const left=xs[cIdx], w=xs[cIdx+1]-xs[cIdx];
        canv.width=w; ctx.clearRect(0,0,canv.width,canv.height);
        ctx.drawImage(image, left, 0, w, naturalH, 0, 0, w, naturalH);
        dataURLs.push(canv.toDataURL('image/png'));
      }
    }else{
      for(let r=0;r<ys.length-1;r++){
        for(let cIdx=0;cIdx<xs.length-1;cIdx++){
          const top=ys[r], h=ys[r+1]-ys[r];
          const left=xs[cIdx], w=xs[cIdx+1]-xs[cIdx];
          canv.width=w; canv.height=h; ctx.clearRect(0,0,w,h);
          ctx.drawImage(image, left, top, w, h, 0, 0, w, h);
          dataURLs.push(canv.toDataURL('image/png'));
        }
      }
    }

    const pieces = dataURLs.map((src,i)=>{
      const href = segLinks[i] || "#";
      return `<a href="${href}" target="_blank" style="display:block;line-height:0;"><img src="${src}" alt="slice-${i+1}" style="display:block;width:100%;height:auto;border:0;"/></a>`;
    }).join("\n");

    codeTA.value = `<!-- Generated by Link Slicer (${segMode}) -->\n<div style="max-width:800px;margin:0 auto;">\n${pieces}\n</div>`;
    btnPreview.disabled=false; btnCopy.disabled=false; btnRegen.disabled=false;

    // 미리보기
    preview.innerHTML="";
    dataURLs.forEach((src,i)=>{
      const a=document.createElement('a'); a.href=segLinks[i]||"#"; a.target="_blank";
      const im=document.createElement('img'); im.src=src; im.alt=`slice-${i+1}`;
      im.style.display="block"; im.style.width="100%"; im.style.height="auto";
      a.appendChild(im); preview.appendChild(a);
    });
  }

  btnGen.addEventListener('click', generateHTML);
  btnRegen.addEventListener('click', generateHTML);
  btnPreview.addEventListener('click', ()=> alert('미리보기가 아래에 표시되었습니다.'));
  btnCopy.addEventListener('click', async ()=>{
    try{ await navigator.clipboard.writeText(codeTA.value); btnCopy.textContent="복사됨"; setTimeout(()=>btnCopy.textContent="코드 복사",1200); }
    catch{ codeTA.select(); document.execCommand("copy"); btnCopy.textContent="복사됨"; setTimeout(()=>btnCopy.textContent="코드 복사",1200); }
  });

  // 상태 저장/불러오기 ------------------------------------------
  function imageToDataURL(){
    const c=document.createElement('canvas'); c.width=naturalW; c.height=naturalH;
    c.getContext('2d').drawImage(image,0,0); return c.toDataURL('image/png');
  }
  function buildState(){
    return {
      version: 5,
      savedAt: new Date().toISOString(),
      mode: segMode,
      rows: uniformRows,
      cols: uniformCols,
      style: { color: styleColor, thickness: styleThickness },
      options: { locked, snapEnabled, snapPx },
      image: imageToDataURL(),
      naturalWidth: naturalW,
      naturalHeight: naturalH,
      lines: lines.map(l=>({type:l.type, perc:l.perc})),
      links: segLinks.slice()
    };
  }
  function downloadJSON(obj, filename){
    const blob=new Blob([JSON.stringify(obj,null,2)],{type:'application/json'});
    const url=URL.createObjectURL(blob);
    const a=document.createElement('a'); a.href=url; a.download=filename||'link-slicer-state.json';
    document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
  }

  btnSaveState.addEventListener('click', ()=>{
    if(!image.src){ alert('이미지를 먼저 업로드하세요.'); return; }
    downloadJSON(buildState(), `link-slicer-state-${Date.now()}.json`);
  });

  btnLoadState.addEventListener('click', ()=>stateFile.click());
  stateFile.addEventListener('change', async (e)=>{
    const f=e.target.files?.[0]; if(!f) return;
    try{
      const text=await f.text(); const state=JSON.parse(text);
      await restoreState(state); alert('상태를 불러왔습니다.');
    }catch(err){ console.error(err); alert('불러오기 실패: JSON을 확인하세요.'); }
    finally{ stateFile.value=""; }
  });

  async function restoreState(state){
    if(!state || !state.image) throw new Error('Invalid state');
    await new Promise((resolve,reject)=>{
      image.onload=()=>{ naturalW=image.naturalWidth; naturalH=image.naturalHeight; stage.style.display='inline-block'; syncOverlaySize(); resolve(); };
      image.onerror=reject; image.src=state.image;
    });

    if(['h','v','grid'].includes(state.mode)){ segMode=state.mode; document.querySelector(`input[name="mode"][value="${segMode}"]`).checked=true; }

    if(typeof state.rows==='number') { uniformRows = Math.max(1, state.rows|0); rowsInput.value = uniformRows; }
    if(typeof state.cols==='number') { uniformCols = Math.max(1, state.cols|0); colsInput.value = uniformCols; }

    if(state.style){
      styleColor = state.style.color || styleColor;
      styleThickness = Math.max(1, parseInt(state.style.thickness||styleThickness,10));
      lineColor.value = styleColor;
      lineThickness.value = styleThickness;
    }
    if(state.options){
      locked = !!state.options.locked; lockToggle.checked = locked;
      snapEnabled = !!state.options.snapEnabled; snapToggle.checked = snapEnabled;
      snapPx = Math.max(0, parseInt(state.options.snapPx||snapPx,10)); snapTol.value = snapPx;
    }

    lines.forEach(l=>l.el.remove()); lines=[];
    state.lines?.forEach(l=>createLine(l.type, Math.max(0,Math.min(1,Number(l.perc)||0))));
    segLinks = Array.isArray(state.links) ? state.links.slice() : [];
    layoutLines();
    updateSegmentsUI(true);
    scheduleThumbs();

    codeTA.value=""; preview.innerHTML="";
    btnGen.disabled=false; btnRegen.disabled=true; btnCopy.disabled=true; btnPreview.disabled=true;
  }

  // 초기화 -----------------------------------------------------
  function clearLinesUI(){ segmentsWrap.innerHTML=''; segLinks=[]; codeTA.value=''; preview.innerHTML=''; btnPreview.disabled=true; btnCopy.disabled=true; btnGen.disabled=!image.src; }
  function fullReset(){ lines.forEach(l=>l.el.remove()); lines=[]; clearLinesUI(); btnGen.disabled=false; btnRegen.disabled=true; btnPreview.disabled=true; btnCopy.disabled=true; }

  // 초기 상태
  btnGen.disabled=true; btnRegen.disabled=true; btnPreview.disabled=true; btnCopy.disabled=true;
  styleColor = lineColor.value; styleThickness = parseInt(lineThickness.value,10)||2;
  locked = lockToggle.checked; snapEnabled = snapToggle.checked; snapPx = parseInt(snapTol.value,10)||8;
})();
</script>
</body>
</html>

