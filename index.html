<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Link Slicer – Outlook Email Ready</title>
<style>
  :root{ --border:#cfd4dc; --muted:#6b7280; --accent:#ff4d4f; --bg:#f7f9fc; --panel:#ffffff; }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{ margin:0; display:flex; min-height:100vh; font-family:system-ui,Segoe UI,Roboto,"Apple SD Gothic Neo",Pretendard,sans-serif; background:var(--bg); color:#111827; }

  #sidebar{ width:300px; border-right:1px solid var(--border); background:var(--panel); display:flex; flex-direction:column; }
  .side-header{padding:18px 16px; border-bottom:1px solid var(--border)}
  .side-header h2{margin:0;font-size:18px}
  .side-body{padding:16px; overflow:auto}
  .muted{color:var(--muted)}
  footer{padding:10px 12px; border-top:1px solid var(--border); background:#fff; font-size:12px;color:#6b7280}

  #dropzone{ margin-top:12px; border:2px dashed #9ca3af; border-radius:12px; background:#fafafa;
    padding:18px; text-align:center; cursor:pointer; transition:all .15s ease; }
  #dropzone.dragover{ border-color:var(--accent); background:#fff1f1 }
  #fileInput{ display:none }

  #main{ flex:1; display:flex; flex-direction:column; min-width:0; }
  #topbar{ padding:12px; border-bottom:1px solid var(--border); background:#fff; display:flex; gap:10px; align-items:center; flex-wrap:wrap;}
  #topbar button{ appearance:none; border:1px solid var(--border); background:#fff; padding:8px 12px; border-radius:10px; cursor:pointer; }
  #topbar button.primary{ border-color:#dbe3ff; background:#eef3ff }
  #topbar .spacer{ flex:1 }
  .pill{font-size:12px;color:#4b5563}
  .segmode,.uniform,.options,.email{display:flex; align-items:center; gap:10px; border:1px solid var(--border); padding:6px 10px; border-radius:10px; background:#fafafa; }
  .uniform input,.options input[type="number"]{ width:64px; padding:6px 8px; border:1px solid var(--border); border-radius:8px; }
  .email input[type="text"]{ width:280px; padding:6px 8px; border:1px solid var(--border); border-radius:8px; }
  .hint{font-size:12px; color:#6b7280}

  #workarea{ display:grid; grid-template-columns:1fr 420px; gap:14px; padding:14px; min-height:0; flex:1; overflow:hidden; }

  #canvas-container{ position:relative; overflow:auto; background:#e5e7eb; border:1px solid var(--border); border-radius:10px;
    display:flex; align-items:flex-start; justify-content:center; padding:18px; min-height:0; }

  #stage{ position:relative; display:none; }
  #uploadedImage{ display:block; max-width:100%; height:auto; border:1px solid var(--border); background:#fff; box-shadow:0 2px 8px rgba(0,0,0,.05); }
  #overlay{ position:absolute; left:0; top:0; z-index:10; pointer-events:auto; }

  .line{ position:absolute; background:var(--accent); cursor:move; box-shadow:0 0 6px rgba(255,77,79,.35); pointer-events:auto; }
  .h-line{ left:0; right:0; }
  .v-line{ top:0;  bottom:0; }

  #rightpanel{ background:#fff; border:1px solid var(--border); border-radius:10px; display:flex; flex-direction:column; min-height:0; }
  #rightpanel header{ padding:12px 12px; border-bottom:1px solid var(--border); font-weight:600 }
  #segments{ padding:12px; overflow:auto; display:flex; flex-direction:column; gap:10px; min-height:0; }

  .segrow{ display:grid; grid-template-columns:76px 1fr; gap:10px; align-items:center; border:1px solid var(--border);
    padding:8px; border-radius:10px; background:#fafafa; }
  .thumb{ width:76px; height:auto; border:1px solid var(--border); border-radius:6px; display:block; background:#fff; }
  .segmeta{ font-size:12px; color:#6b7280; margin-top:4px }
  .segrow input{ width:100%; padding:8px 10px; border:1px solid var(--border); border-radius:8px; }

  #codebox{ padding:12px; border-top:1px solid var(--border); display:flex; flex-direction:column; gap:8px; }
  #code{ width:100%; min-height:160px; border:1px solid var(--border); border-radius:8px; padding:10px; font-family:ui-monospace,Consolas,monospace; }

  /* 페이지 내 미리보기 숨김(새 탭만 사용) */
  #previewwrap{ display:none; }

  #stateFile{ display:none }

  @media (max-width: 1160px){ #workarea{ grid-template-columns:1fr; } }
</style>
</head>
<body>
<aside id="sidebar">
  <div class="side-header"><h2>     [사용법 요약]</h2></div>
  <div class="side-body">
    <ol style="margin:0;padding-left:20px">
      <li>이미지 업로드</li>
      <li>   (아래 박스에 <b>드래그&드롭</b> 또는 클릭)</li>
      <li>조각 기준에 따라 선 추가<br>
        • 가로: <b>Ctrl+클릭</b>=가로선 추가<br>
        • 세로: <b>Ctrl+클릭</b>=세로선 추가<br>
        • 가로×세로: <b>Ctrl+클릭</b>=가로, <b>Ctrl+Shift+클릭</b>=세로<br>
        • 분할선 삭제: <b>Alt+클릭</b><br></li>
      <li>우측 조각 링크 입력</li>
      <li>HTML 생성/복사</li>
      <li>미리보기 클릭 후 복사</li>
    </ol>
    <div id="dropzone">
      <div style="font-weight:600; margin-bottom:4px;">이미지 업로드</div>
      <div class="muted">여기에 파일을 드래그하거나 클릭하세요</div>
      <div style="font-size:12px;color:#9ca3af;margin-top:6px;">(PNG · JPG · GIF)</div>
      <input id="fileInput" type="file" accept="image/*">
    </div>
  </div>
  <footer>라인/링크/세그먼트가 모드별로 독립 동작합니다.</footer>
</aside>

<main id="main">
  <div id="topbar">
    <button id="btnGen" class="primary" disabled>HTML 생성</button>
    <button id="btnRegen" disabled>HTML 재생성</button>
    <button id="btnCopy" disabled>코드 복사</button>
    <span class="spacer"></span>

    <div class="segmode" title="조각 기준">
      조각 기준:
      <label><input type="radio" name="mode" value="h" checked> 가로</label>
      <label><input type="radio" name="mode" value="v"> 세로</label>
      <label><input type="radio" name="mode" value="grid"> 가로x세로</label>
    </div>

    <div class="uniform" title="균등 간격 자동 분할">
      Row(행): <input id="rowsInput" type="number" min="1" value="3">
      Col(열): <input id="colsInput" type="number" min="1" value="3">
      <button id="btnUniform">균등분할 적용</button>
      <div class="hint">가로: Row만, 세로: Col만 사용</div>
    </div>

    <div class="options" title="스냅/잠금/선 스타일">
      <label><input id="lockToggle" type="checkbox"> 선 잠금</label>
      <label><input id="snapToggle" type="checkbox" checked> 스냅</label>
      스냅(px): <input id="snapTol" type="number" min="0" value="8">
      색상: <input id="lineColor" type="color" value="#ff4d4f">
      두께(px): <input id="lineThickness" type="number" min="1" value="2">
    </div>

    <div class="email" title="Outlook 호환 이메일 모드">
      <label><input id="emailMode" type="checkbox"> 이메일 모드(Outlook)</label>
      <label>
        참조 방식:
        <select id="emailImgRef">
          <option value="url" selected>URL</option>
          <option value="cid">CID(첨부)</option>
        </select>
      </label>
      <label id="baseLabel">이미지 URL 접두어:
        <input id="emailBase" type="text" placeholder="https://cdn.example.com/newsletter">
      </label>
      <div class="hint">이메일 모드: data:URL 미사용. URL 또는 CID로만 삽입</div>
    </div>

    <span class="spacer"></span>
    <button id="btnSaveState" title="현재 작업 저장(JSON 다운로드)">상태 저장</button>
    <button id="btnLoadState" title="저장한 JSON 불러오기">상태 불러오기</button>
    <input id="stateFile" type="file" accept="application/json" />
    <button id="btnClearLines">선 모두 삭제</button>
    <span class="pill">Alt 삭제는 “표시중인” 선만 대상</span>
  </div>

  <div id="workarea">
    <div id="canvas-container">
      <div id="stage">
        <img id="uploadedImage" alt="업로드 이미지">
        <div id="overlay"></div>
      </div>
    </div>

    <div id="rightpanel">
      <header>조각 링크 입력 + 썸네일</header>
      <div id="segments"></div>
      <div id="codebox">
        <button id="btnPreview" disabled>미리보기 생성</button>
        <textarea id="code" placeholder="HTML 생성 후 코드가 표시됩니다" readonly></textarea>
      </div>
    </div>
  </div>
</main>

<script>
(() => {
  // ===== 고정 상수: 가장자리/병합 허용 오차 =====
  const EDGE_EPS  = 0.002; // 0.2%
  const MERGE_EPS = 0.002; // 0.2%

  const dropzone = document.getElementById('dropzone');
  const fileInput = document.getElementById('fileInput');
  const stateFile = document.getElementById('stateFile');

  const stage = document.getElementById('stage');
  const overlay = document.getElementById('overlay');
  const image = document.getElementById('uploadedImage');

  const segmentsWrap = document.getElementById('segments');
  const btnGen = document.getElementById('btnGen');
  const btnRegen = document.getElementById('btnRegen');
  const btnCopy = document.getElementById('btnCopy');
  const btnClearLines = document.getElementById('btnClearLines');
  const btnPreview = document.getElementById('btnPreview');
  const btnSaveState = document.getElementById('btnSaveState');
  const btnLoadState = document.getElementById('btnLoadState');
  const codeTA = document.getElementById('code');

  const modeRadios = document.querySelectorAll('input[name="mode"]');
  const rowsInput = document.getElementById('rowsInput');
  const colsInput = document.getElementById('colsInput');
  const btnUniform = document.getElementById('btnUniform');

  const lockToggle = document.getElementById('lockToggle');
  const snapToggle = document.getElementById('snapToggle');
  const snapTol = document.getElementById('snapTol');
  const lineColor = document.getElementById('lineColor');
  const lineThickness = document.getElementById('lineThickness');

  const emailMode = document.getElementById('emailMode');
  const emailImgRef = document.getElementById('emailImgRef');
  const emailBase = document.getElementById('emailBase');
  const baseLabel = document.getElementById('baseLabel');

  let lines = []; // { type:'h'|'v', perc:0..1, el, origin:'h'|'v'|'grid' }
  let naturalW = 0, naturalH = 0;

  let linkStore = { h: [], v: [], grid: [] };

  let thumbRAF = null;
  let segMode = 'h';
  let uniformRows = 3, uniformCols = 3;

  let styleColor = '#ff4d4f';
  let styleThickness = 2;
  let locked = false;
  let snapEnabled = true;
  let snapPx = 8;
  let isDragging = false;

  function displaySize(){ return { w: overlay.clientWidth, h: overlay.clientHeight }; }
  function syncOverlaySize(){ overlay.style.width=image.clientWidth+'px'; overlay.style.height=image.clientHeight+'px'; }
  function isVisibleByMode(l){ return l.origin === segMode; }

  function applyStyle(el, type){
    el.style.background = styleColor;
    if(type==='h'){ el.style.height = styleThickness + 'px'; el.className='line h-line'; }
    else          { el.style.width  = styleThickness + 'px'; el.className='line v-line'; }
    el.style.boxShadow = `0 0 6px ${styleColor}55`;
  }

  function layoutLines(){
    const {w,h} = displaySize();
    lines.forEach(l=>{
      if(l.type==='h'){
        l.el.style.left='0'; l.el.style.right='0';
        l.el.style.top=(l.perc*h - styleThickness/2) + 'px';
      }else{
        l.el.style.top='0'; l.el.style.bottom='0';
        l.el.style.left=(l.perc*w - styleThickness/2) + 'px';
      }
      applyStyle(l.el, l.type);
      const visible = isVisibleByMode(l);
      l.el.style.display = visible ? '' : 'none';
      l.el.style.cursor = visible ? (locked ? 'default' : 'move') : 'default';
      l.el.style.pointerEvents = (visible && !locked) ? 'auto' : 'none';
    });
  }

  // 원시 컷 가져오기(현재 모드 + 타입)
  function getPercsRaw(type){
    return lines
      .filter(l=>l.origin===segMode && l.type===type)
      .map(l=>l.perc);
  }

  // 가장자리 제거 + 근접 병합(정규화 컷 계산)
  function getCutsNormalized(type){
    const arr = getPercsRaw(type)
      .filter(p => p > EDGE_EPS && p < 1-EDGE_EPS) // 가장자리 선 제거
      .sort((a,b)=>a-b);

    const merged = [];
    for(const p of arr){
      if(merged.length===0) { merged.push(p); continue; }
      const last = merged[merged.length-1];
      if(Math.abs(p - last) <= MERGE_EPS){
        // 가까우면 평균으로 병합
        merged[merged.length-1] = (last + p)/2;
      } else {
        merged.push(p);
      }
    }
    return merged;
  }

  // UI/썸네일/HTML 등에서 사용할 "안전한 컷 배열" 반환
  function getSafeCuts(type){
    return getCutsNormalized(type);
  }

  function markDirty(){
    btnRegen.disabled = false;
    btnPreview.disabled = true;
    btnCopy.disabled = true;
    codeTA.value = '';
  }

  function loadFile(file){
    if(!file) return;
    const url = URL.createObjectURL(file);
    image.onload = () => {
      naturalW = image.naturalWidth; naturalH = image.naturalHeight;
      stage.style.display='inline-block';
      syncOverlaySize(); fullReset();
    };
    image.src=url;
  }

  dropzone.addEventListener('click', ()=>fileInput.click());
  fileInput.addEventListener('change', e=>loadFile(e.target.files?.[0]));
  ['dragenter','dragover'].forEach(t=>dropzone.addEventListener(t, e=>{e.preventDefault(); dropzone.classList.add('dragover');}));
  ['dragleave','dragend','drop'].forEach(t=>dropzone.addEventListener(t, ()=>dropzone.classList.remove('dragover')));
  dropzone.addEventListener('drop', e=>{ e.preventDefault(); const f=e.dataTransfer.files?.[0]; if(f?.type.startsWith('image/')) loadFile(f); });

  function pointerInOverlay(ev){
    const r = overlay.getBoundingClientRect();
    const x = ev.clientX - r.left, y = ev.clientY - r.top;
    const w = overlay.clientWidth, h = overlay.clientHeight;
    return {x,y,w,h, inside:x>=0&&y>=0&&x<=w&&y<=h};
  }

  function createLine(type, perc, origin){
    const el = document.createElement('div');
    overlay.appendChild(el);
    const obj = {type, perc: Math.max(0, Math.min(1, perc)), el, origin};
    lines.push(obj);
    applyStyle(el, type);
    layoutLines();
    updateSegmentsUI(true);
    markDirty();

    let startClient=0, startPerc=obj.perc;

    // 선 클릭이 overlay 클릭으로 전파되어 "추가 생성"되는 문제 방지
    el.addEventListener('click', (e)=> e.stopPropagation());

    el.addEventListener('mousedown', (e)=>{
      if(locked || !isVisibleByMode(obj)) return;
      if(e.button !== 0) return;
      e.preventDefault();
      e.stopPropagation();
      isDragging = true;

      startClient=(type==='h')?e.clientY:e.clientX; startPerc=obj.perc;

      const onMove=(ev)=>{
        const {w,h}=displaySize();
        const d=(type==='h')? (ev.clientY-startClient)/h : (ev.clientX-startClient)/w;
        let next = Math.max(0, Math.min(1, startPerc+d));

        if(snapEnabled){
          const pxTol = snapPx;
          const currPx = (type==='h') ? next*h : next*w;
          let snapTargets = [0, (type==='h')?h:w];
          lines.forEach(l=>{
            if(l!==obj && l.type===type && l.origin===segMode) {
              snapTargets.push((type==='h')? l.perc*h : l.perc*w);
            }
          });
          let best = currPx, bestDist = Infinity;
          for(const t of snapTargets){
            const dist = Math.abs(currPx - t);
            if(dist <= pxTol && dist < bestDist){ best = t; bestDist = dist; }
          }
          if(bestDist !== Infinity){ next = (type==='h') ? best/h : best/w; }
        }

        obj.perc = next;
        layoutLines();
        scheduleThumbs();
        markDirty();
      };

      const onUp=()=>{
        document.removeEventListener('mousemove', onMove);
        document.removeEventListener('mouseup', onUp);

        // 드래그 완료 후: 가장자리 정규화/근접 병합 반영
        normalizeAndCleanup(obj.type);

        updateSegmentsUI(false);
        // 드래그 종료 후 click 이벤트가 추가 실행되지 않도록 한 틱 뒤에 플래그 해제
        setTimeout(()=>{ isDragging = false; }, 0);
      };

      document.addEventListener('mousemove', onMove);
      document.addEventListener('mouseup', onUp);
    });
  }

  // 현재 모드의 해당 타입(h/v) 라인에 대해 가장자리 제거·근접 병합 후 재적용
  function normalizeAndCleanup(type){
    const keep = [];
    // 현재 모드 + 타입만 추출
    const subset = lines.filter(l=>l.origin===segMode && l.type===type).sort((a,b)=>a.perc-b.perc);
    // 가장자리 제외
    const filtered = subset.filter(l => l.perc > EDGE_EPS && l.perc < 1-EDGE_EPS);

    // 근접 병합
    for(const l of filtered){
      if(keep.length===0) { keep.push(l); continue; }
      const last = keep[keep.length-1];
      if(Math.abs(l.perc - last.perc) <= MERGE_EPS){
        last.perc = (last.perc + l.perc)/2;
        // 중복 라인 DOM 제거
        l.el.remove();
        // 전체 목록에서 제거
        lines = lines.filter(x=>x!==l);
      }else{
        keep.push(l);
      }
    }

    // 가장자리였던 라인 DOM 제거
    subset.forEach(l=>{
      if(l.perc <= EDGE_EPS || l.perc >= 1-EDGE_EPS){
        l.el.remove();
        lines = lines.filter(x=>x!==l);
      }
    });

    layoutLines();
    scheduleThumbs();
  }

  function deleteNearest(x,y){
    const {w,h}=displaySize();
    let nearest=null, dist=Infinity;
    lines.forEach(l=>{
      if(l.origin!==segMode) return;
      const d=(l.type==='h')?Math.abs(l.perc*h-y):Math.abs(l.perc*w-x);
      if(d<dist){dist=d; nearest=l;}
    });
    if(nearest){
      nearest.el.remove();
      lines = lines.filter(l=>l!==nearest);
      updateSegmentsUI(true);
      markDirty();
    }
  }

  // Alt+클릭 삭제, Ctrl(+Shift)+클릭 생성 (드래그 클릭 방지)
  overlay.addEventListener('click', e=>{
    if(!image.src) return;
    if(e.button !== 0) return;
    if(isDragging) return;
    const p=pointerInOverlay(e); if(!p.inside) return;

    if(e.altKey){ deleteNearest(p.x,p.y); return; }
    if(!e.ctrlKey) return;

    if(segMode==='h'){ createLine('h', p.y/p.h, 'h'); return; }
    if(segMode==='v'){ createLine('v', p.x/p.w, 'v'); return; }
    const addType = e.shiftKey ? 'v' : 'h';
    if(addType==='h') createLine('h', p.y/p.h, 'grid'); else createLine('v', p.x/p.w, 'grid');
  });

  function ensureLinkStoreSize(len){
    const arr = linkStore[segMode];
    if(arr.length < len){ for(let i=arr.length;i<len;i++) arr.push(""); }
    else if(arr.length > len){ arr.length = len; }
  }

  modeRadios.forEach(r=>r.addEventListener('change', ()=>{
    segMode = [...modeRadios].find(x=>x.checked).value;
    layoutLines();
    updateSegmentsUI(true);
    markDirty();
  }));

  function rebuildUniformForMode(rows, cols){
    if(segMode==='h'){
      lines.filter(l=>l.origin==='h' && l.type==='h').forEach(l=>l.el.remove());
      lines = lines.filter(l=>!(l.origin==='h' && l.type==='h'));
      const count = Math.max(1, rows|0);
      for(let i=1;i<=count-1;i++) createLine('h', i/count, 'h');
    }else if(segMode==='v'){
      lines.filter(l=>l.origin==='v' && l.type==='v').forEach(l=>l.el.remove());
      lines = lines.filter(l=>!(l.origin==='v' && l.type==='v'));
      const count = Math.max(1, cols|0);
      for(let i=1;i<=count-1;i++) createLine('v', i/count, 'v');
    }else{
      lines.filter(l=>l.origin==='grid').forEach(l=>l.el.remove());
      lines = lines.filter(l=>!(l.origin==='grid'));
      const rCnt = Math.max(1, rows|0), cCnt = Math.max(1, cols|0);
      for(let i=1;i<=rCnt-1;i++) createLine('h', i/rCnt, 'grid');
      for(let j=1;j<=cCnt-1;j++) createLine('v', j/cCnt, 'grid');
    }
    // 재구성 후 가장자리/근접 병합 한번 수행
    normalizeAndCleanup('h');
    normalizeAndCleanup('v');

    layoutLines();
    updateSegmentsUI(true);
    scheduleThumbs(); markDirty();
  }

  btnUniform.addEventListener('click', ()=>{
    const rows = Math.max(1, parseInt(rowsInput.value||'1',10));
    const cols = Math.max(1, parseInt(colsInput.value||'1',10));
    uniformRows = rows; uniformCols = cols;
    rebuildUniformForMode(rows, cols);
  });

  lockToggle.addEventListener('change', ()=>{ locked = lockToggle.checked; layoutLines(); });
  snapToggle.addEventListener('change', ()=>{ snapEnabled = snapToggle.checked; });
  snapTol.addEventListener('input', ()=>{ snapPx = Math.max(0, parseInt(snapTol.value||'0',10)); });
  lineColor.addEventListener('input', ()=>{ styleColor = lineColor.value || '#ff4d4f'; layoutLines(); });
  lineThickness.addEventListener('input', ()=>{ styleThickness = Math.max(1, parseInt(lineThickness.value||'2',10)); layoutLines(); });

  emailImgRef.addEventListener('change', ()=>{
    baseLabel.style.display = (emailImgRef.value==='url') ? '' : 'none';
  });
  baseLabel.style.display = (emailImgRef.value==='url') ? '' : 'none';

  const ro=new ResizeObserver(()=>{ syncOverlaySize(); layoutLines(); scheduleThumbs(); });
  ro.observe(image); ro.observe(stage);

  btnClearLines.addEventListener('click', ()=>{
    lines.filter(l=>l.origin===segMode).forEach(l=>l.el.remove());
    lines = lines.filter(l=>l.origin!==segMode);
    updateSegmentsUI(true);
    markDirty();
  });

  function scheduleThumbs(){ if(thumbRAF) cancelAnimationFrame(thumbRAF); thumbRAF=requestAnimationFrame(renderThumbnails); }

  function updateSegmentsUI(regenThumbs){
    let rows=1, cols=1, hCuts=[], vCuts=[];
    if(segMode==='h'){ hCuts=getSafeCuts('h'); rows=hCuts.length+1; cols=1; }
    else if(segMode==='v'){ vCuts=getSafeCuts('v'); rows=1; cols=vCuts.length+1; }
    else{ hCuts=getSafeCuts('h'); vCuts=getSafeCuts('v'); rows=hCuts.length+1; cols=vCuts.length+1; }

    const total = rows*cols;
    ensureLinkStoreSize(total);

    segmentsWrap.innerHTML="";
    for(let r=0;r<rows;r++){
      for(let c=0;c<cols;c++){
        const idx = r*cols + c;
        const row = document.createElement('div');
        row.className='segrow'; row.dataset.idx=idx;

        const left = document.createElement('div');
        const img  = document.createElement('img'); img.className='thumb'; img.alt=`seg-${idx+1}`;
        left.appendChild(img);

        const meta = document.createElement('div'); meta.className='segmeta';
        if(segMode==='h') meta.textContent = `조각 ${idx+1} · 행 ${r+1}/${rows}`;
        else if(segMode==='v') meta.textContent = `조각 ${idx+1} · 열 ${c+1}/${cols}`;
        else meta.textContent = `조각 ${idx+1} · (${r+1}, ${c+1}) / ${rows}×${cols}`;
        left.appendChild(meta);

        const input = document.createElement('input');
        input.type='url'; input.placeholder='https:// 링크 입력'; input.value=linkStore[segMode][idx] || "";
        input.addEventListener('input', ev=>{
          linkStore[segMode][idx] = ev.target.value.trim();
          markDirty();
        });

        row.appendChild(left); row.appendChild(input);
        segmentsWrap.appendChild(row);
      }
    }

    btnGen.disabled = !image.src;
    btnPreview.disabled=true; btnCopy.disabled=true; codeTA.value='';
    if(regenThumbs) scheduleThumbs();
  }

  function renderThumbnails(){
    thumbRAF=null; if(!image.src) return;

    const hPerc=[0,...getSafeCuts('h'),1];
    const vPerc=[0,...getSafeCuts('v'),1];

    const ys=hPerc.map(p=>Math.round(p*naturalH));
    const xs=vPerc.map(p=>Math.round(p*naturalW));

    const c=document.createElement('canvas'); const ctx=c.getContext('2d');

    if(segMode==='h'){
      let idx=0;
      for(let r=0;r<ys.length-1;r++){
        const top=ys[r], h=ys[r+1]-ys[r];
        const W=76, H=Math.max(1, Math.round(h*(W/naturalW)));
        c.width=W; c.height=H; ctx.clearRect(0,0,W,H);
        ctx.drawImage(image, 0, top, naturalW, h, 0, 0, W, H);
        const url=c.toDataURL('image/png');
        const imgEl=segmentsWrap.querySelector(`.segrow[data-idx="${idx}"] img.thumb`);
        if(imgEl){ imgEl.src=url; imgEl.style.width=W+'px'; }
        idx++;
      }
      return;
    }

    if(segMode==='v'){
      let idx=0;
      for(let ci=0;ci<xs.length-1;ci++){
        const left=xs[ci], w=xs[ci+1]-xs[ci];
        const H=76, W=Math.max(1, Math.round(w*(H/naturalH)));
        c.width=W; c.height=H; ctx.clearRect(0,0,W,H);
        ctx.drawImage(image, left, 0, w, naturalH, 0, 0, W, H);
        const url=c.toDataURL('image/png');
        const imgEl=segmentsWrap.querySelector(`.segrow[data-idx="${idx}"] img.thumb`);
        if(imgEl){ imgEl.src=url; imgEl.style.width=W+'px'; }
        idx++;
      }
      return;
    }

    // grid
    let idx=0;
    for(let r=0;r<ys.length-1;r++){
      for(let ci=0;ci<xs.length-1;ci++){
        const top=ys[r], h=ys[r+1]-ys[r];
        const left=xs[ci], w=xs[ci+1]-xs[ci];
        if(w<=0||h<=0){ idx++; continue; }
        const box=76, scale=Math.min(box/w, box/h);
        const W=Math.max(1, Math.round(w*scale));
        const H=Math.max(1, Math.round(h*scale));
        c.width=W; c.height=H; ctx.clearRect(0,0,W,H);
        ctx.drawImage(image, left, top, w, h, 0, 0, W, H);
        const url=c.toDataURL('image/png');
        const imgEl=segmentsWrap.querySelector(`.segrow[data-idx="${idx}"] img.thumb`);
        if(imgEl){ imgEl.src=url; imgEl.style.width=W+'px'; }
        idx++;
      }
    }
  }

  // 조각 PNG를 파일로 다운로드(이메일 모드 URL 방식 보조)
  function downloadSlices(blobs, names){
    blobs.forEach((blob, i)=>{
      const a=document.createElement('a');
      a.href=URL.createObjectURL(blob);
      a.download=names[i];
      document.body.appendChild(a);
      a.click();
      a.remove();
      setTimeout(()=>URL.revokeObjectURL(a.href), 5000);
    });
  }

  // === HTML 생성 === (Outlook 대응: 전부 table 기반)
  function generateHTML(){
    if(!image.src) return;

    const hCut = getSafeCuts('h');
    const vCut = getSafeCuts('v');

    const hPerc=[0,...hCut,1];
    const vPerc=[0,...vCut,1];

    const ys=hPerc.map(p=>Math.round(p*naturalH));
    const xs=vPerc.map(p=>Math.round(p*naturalW));

    const canv=document.createElement('canvas');
    const ctx=canv.getContext('2d');
    const currentLinks = linkStore[segMode];

    const wantEmail = emailMode.checked;
    const refType = emailImgRef.value; // 'url' | 'cid'
    const base = (emailBase.value||'').replace(/\/+$/,''); // trim tail slash
    const blobs = [];
    const fnames = [];

    function imgSrcFrom(dataUrl, fileName){
      if(!wantEmail){
        return dataUrl; // 일반 모드: data URL 사용
      }
      if(refType==='url'){
        return base ? `${base}/${fileName}` : fileName; // 접두어 없으면 파일명만(후속 호스팅/첨부 시 수정 가능)
      }
      // CID
      return `cid:${fileName}`;
    }

    function pushBlob(dataUrl, fileName){
      if(wantEmail){
        const arr = dataUrl.split(',');
        const bstr = atob(arr[1]);
        let n = bstr.length;
        const u8 = new Uint8Array(n);
        while(n--){ u8[n] = bstr.charCodeAt(n); }
        blobs.push(new Blob([u8], {type:'image/png'}));
        fnames.push(fileName);
      }
    }

    // 가로 모드: 1열 n행
    if(segMode==='h'){
      canv.width=naturalW;
      const rowsHtml=[];
      for(let r=0;r<ys.length-1;r++){
        const top=ys[r], h=ys[r+1]-ys[r];
        canv.height=h; ctx.clearRect(0,0,canv.width,canv.height);
        ctx.drawImage(image, 0, top, naturalW, h, 0, 0, naturalW, h);
        const dataUrl=canv.toDataURL('image/png');
        const fname=`slice-h-${r+1}.png`;
        const src=imgSrcFrom(dataUrl, fname);
        pushBlob(dataUrl, fname);

        const href=(currentLinks[r]||"").trim();
        const imgTag=`<img src="${src}" alt="slice-${r+1}" width="800" style="display:block;border:0;width:100%;height:auto;" />`;
        const inner = href ? `<a href="${href}" target="_blank" style="text-decoration:none;">${imgTag}</a>` : imgTag;
        rowsHtml.push(`<tr><td style="padding:0;border:none;">${inner}</td></tr>`);
      }
      const table = `<table role="presentation" cellspacing="0" cellpadding="0" border="0" style="border-collapse:collapse;border-spacing:0;width:100%;">\n${rowsHtml.join("\n")}\n</table>`;
      codeTA.value = `<!-- Generated by Link Slicer (h) Outlook-safe -->\n<div style="max-width:800px;margin:0 auto;">\n${table}\n</div>`;
      btnPreview.disabled=false; btnCopy.disabled=false; btnRegen.disabled=false;
      if(wantEmail && refType==='url'){ downloadSlices(blobs, fnames); }
      return;
    }

    // 세로 모드: 1행 n열 (열 너비 % 지정 + img width 지정)
    if(segMode==='v'){
      canv.height=naturalH;
      const tds=[];
      for(let ci=0;ci<xs.length-1;ci++){
        const left=xs[ci], w=xs[ci+1]-xs[ci];
        canv.width=w; ctx.clearRect(0,0,canv.width,canv.height);
        ctx.drawImage(image, left, 0, w, naturalH, 0, 0, w, naturalH);
        const dataUrl=canv.toDataURL('image/png');
        const fname=`slice-v-${ci+1}.png`;
        const src=imgSrcFrom(dataUrl, fname);
        pushBlob(dataUrl, fname);

        const href=(currentLinks[ci]||"").trim();
        const pct = (w / naturalW * 100).toFixed(6);
        const imgTag=`<img src="${src}" alt="slice-${ci+1}" width="${Math.round(800 * (w/naturalW))}" style="display:block;border:0;width:100%;height:auto;" />`;
        const inner = href ? `<a href="${href}" target="_blank" style="text-decoration:none;">${imgTag}</a>` : imgTag;
        tds.push(`<td width="${pct}%" style="padding:0;border:none;width:${pct}%;vertical-align:top;">${inner}</td>`);
      }
      const table = `<table role="presentation" cellspacing="0" cellpadding="0" border="0" style="border-collapse:collapse;border-spacing:0;width:100%;"><tr>\n${tds.join("\n")}\n</tr></table>`;
      codeTA.value = `<!-- Generated by Link Slicer (v) Outlook-safe -->\n<div style="max-width:800px;margin:0 auto;">\n${table}\n</div>`;
      btnPreview.disabled=false; btnCopy.disabled=false; btnRegen.disabled=false;
      if(wantEmail && refType==='url'){ downloadSlices(blobs, fnames); }
      return;
    }

    // 그리드 모드: r×c
    if(segMode==='grid'){
      const rows = ys.length-1, cols = xs.length-1;
      const rowsHtml=[];
      for(let r=0;r<rows;r++){
        const tds=[];
        for(let c=0;c<cols;c++){
          const top=ys[r], h=ys[r+1]-ys[r];
          const left=xs[c], w=xs[c+1]-xs[c];
          canv.width=w; canv.height=h; ctx.clearRect(0,0,w,h);
          ctx.drawImage(image, left, top, w, h, 0, 0, w, h);
          const dataUrl=canv.toDataURL('image/png');
          const flatIndex = r*cols + c;
          const fname=`slice-grid-${r+1}-${c+1}.png`;
          const src=imgSrcFrom(dataUrl, fname);
          pushBlob(dataUrl, fname);

          const href=(currentLinks[flatIndex]||"").trim();
          const pct = (w / naturalW * 100).toFixed(6);
          const imgTag=`<img src="${src}" alt="cell-${r+1}-${c+1}" width="${Math.round(800 * (w/naturalW))}" style="display:block;border:0;width:100%;height:auto;" />`;
          const inner = href ? `<a href="${href}" target="_blank" style="text-decoration:none;">${imgTag}</a>` : imgTag;
          tds.push(`<td width="${pct}%" style="padding:0;border:none;width:${pct}%;vertical-align:top;">${inner}</td>`);
        }
        rowsHtml.push(`<tr>${tds.join("")}</tr>`);
      }
      const table = `<table role="presentation" cellspacing="0" cellpadding="0" border="0" style="border-collapse:collapse;border-spacing:0;width:100%;">\n${rowsHtml.join("\n")}\n</table>`;
      codeTA.value = `<!-- Generated by Link Slicer (grid) Outlook-safe -->\n<div style="max-width:800px;margin:0 auto;">\n${table}\n</div>`;
      btnPreview.disabled=false; btnCopy.disabled=false; btnRegen.disabled=false;
      if(wantEmail && refType==='url'){ downloadSlices(blobs, fnames); }
      return;
    }
  }

  btnGen.addEventListener('click', generateHTML);
  btnRegen.addEventListener('click', generateHTML);

  btnPreview.addEventListener('click', () => {
    if (!codeTA.value.trim()) {
      alert('HTML을 먼저 생성해주세요.');
      return;
    }
    const win = window.open('', '_blank');
    if (!win) { alert('팝업이 차단되었습니다. 브라우저 설정에서 허용해주세요.'); return; }

    const htmlDoc = `
<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1.0">
<title>Link Slicer Preview (${segMode})</title>
<style>
body { margin:0; padding:20px; font-family:system-ui, sans-serif; background:#fafafa; }
a { text-decoration:none; }
img { display:block; max-width:100%; height:auto; margin:0 auto; border:none; }
.container { max-width:800px; margin:0 auto; }
.notice { font-size:13px; color:#888; text-align:center; margin-bottom:10px; }
</style>
</head>
<body>
<div class="notice">미리보기 – 이메일 모드에서 이미지 URL 또는 CID를 확인하세요.</div>
<div class="container">
${codeTA.value
  .replace(/<!--[\s\S]*?-->/g, '')
  .replace(/^<div[^>]*>|<\/div>$/g, '')
}
</div>
</body>
</html>`;
    win.document.open();
    win.document.write(htmlDoc);
    win.document.close();
  });

  btnCopy.addEventListener('click', async ()=>{
    try{ await navigator.clipboard.writeText(codeTA.value); btnCopy.textContent="복사됨"; setTimeout(()=>btnCopy.textContent="코드 복사",1200); }
    catch{ codeTA.select(); document.execCommand("copy"); btnCopy.textContent="복사됨"; setTimeout(()=>btnCopy.textContent="코드 복사",1200); }
  });

  function imageToDataURL(){
    const c=document.createElement('canvas'); c.width=naturalW; c.height=naturalH;
    c.getContext('2d').drawImage(image,0,0); return c.toDataURL('image/png');
  }

  function buildState(){
    return {
      version: 13,
      savedAt: new Date().toISOString(),
      mode: segMode,
      rows: uniformRows,
      cols: uniformCols,
      style: { color: styleColor, thickness: styleThickness },
      options: { locked, snapEnabled, snapPx },
      image: imageToDataURL(),
      naturalWidth: naturalW,
      naturalHeight: naturalH,
      lines: lines.map(l=>({type:l.type, perc:l.perc, origin:l.origin})),
      links: linkStore
    };
  }

  function downloadJSON(obj, filename){
    const blob=new Blob([JSON.stringify(obj,null,2)],{type:'application/json'});
    const url=URL.createObjectURL(blob);
    const a=document.createElement('a'); a.href=url; a.download=filename||'link-slicer-state.json';
    document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
  }

  btnSaveState.addEventListener('click', ()=>{
    if(!image.src){ alert('이미지를 먼저 업로드하세요.'); return; }
    downloadJSON(buildState(), `link-slicer-state-${Date.now()}.json`);
  });

  btnLoadState.addEventListener('click', ()=>stateFile.click());
  stateFile.addEventListener('change', async (e)=>{
    const f=e.target.files?.[0]; if(!f) return;
    try{
      const text=await f.text(); const state=JSON.parse(text);
      await restoreState(state); alert('상태를 불러왔습니다.');
    }catch(err){ console.error(err); alert('불러오기 실패: JSON을 확인하세요.'); }
    finally{ stateFile.value=""; }
  });

  async function restoreState(state){
    if(!state || !state.image) throw new Error('Invalid state');
    await new Promise((resolve,reject)=>{
      image.onload=()=>{ naturalW=image.naturalWidth; naturalH=image.naturalHeight; stage.style.display='inline-block'; syncOverlaySize(); resolve(); };
      image.onerror=reject; image.src=state.image;
    });

    if(['h','v','grid'].includes(state.mode)){ segMode=state.mode; document.querySelector(`input[name="mode"][value="${segMode}"]`).checked=true; }
    if(typeof state.rows==='number') { uniformRows = Math.max(1, state.rows|0); rowsInput.value = uniformRows; }
    if(typeof state.cols==='number') { uniformCols = Math.max(1, state.cols|0); colsInput.value = uniformCols; }

    if(state.style){
      styleColor = state.style.color || styleColor;
      styleThickness = Math.max(1, parseInt(state.style.thickness||styleThickness,10));
      lineColor.value = styleColor; lineThickness.value = styleThickness;
    }
    if(state.options){
      locked = !!state.options.locked; lockToggle.checked = locked;
      snapEnabled = !!state.options.snapEnabled; snapToggle.checked = snapEnabled;
      snapPx = Math.max(0, parseInt(state.options.snapPx||snapPx,10)); snapTol.value = snapPx;
    }

    lines.forEach(l=>l.el.remove()); lines=[];
    state.lines?.forEach(l=>createLine(l.type, Math.max(0,Math.min(1,Number(l.perc)||0)), l.origin==='h'?'h':l.origin==='v'?'v':'grid'));
    // 복원 후 가장자리/근접 병합 수행
    normalizeAndCleanup('h');
    normalizeAndCleanup('v');

    layoutLines();

    if(state.links && typeof state.links==='object'){
      linkStore.h  = Array.isArray(state.links.h)    ? state.links.h.slice() : [];
      linkStore.v  = Array.isArray(state.links.v)    ? state.links.v.slice() : [];
      linkStore.grid = Array.isArray(state.links.grid)? state.links.grid.slice() : [];
    }else{
      linkStore = { h:[], v:[], grid:[] };
    }

    updateSegmentsUI(true);
    scheduleThumbs();

    codeTA.value="";
    btnGen.disabled=false; btnRegen.disabled=true; btnCopy.disabled=true; btnPreview.disabled=true;
  }

  function clearLinesUI(){ segmentsWrap.innerHTML=''; codeTA.value=''; btnPreview.disabled=true; btnCopy.disabled=true; btnGen.disabled=!image.src; }
  function fullReset(){ lines.forEach(l=>l.el.remove()); lines=[]; linkStore={h:[],v:[],grid:[]}; clearLinesUI(); btnGen.disabled=false; btnRegen.disabled=true; btnPreview.disabled=true; btnCopy.disabled=true; }

  // 초기 상태
  btnGen.disabled=true; btnRegen.disabled=true; btnPreview.disabled=true; btnCopy.disabled=true;
  styleColor = lineColor.value; styleThickness = parseInt(lineThickness.value,10)||2;
  locked = lockToggle.checked; snapEnabled = snapToggle.checked; snapPx = parseInt(snapTol.value,10)||8;
})();
</script>
</body>
</html>



